{"ast":null,"code":"// TODO(v3): checksum address.\nimport { AbiEventSignatureNotFoundError, DecodeLogDataMismatch, DecodeLogTopicsMismatch } from '../../errors/abi.js';\nimport { isAddressEqual } from '../address/isAddressEqual.js';\nimport { toBytes } from '../encoding/toBytes.js';\nimport { keccak256 } from '../hash/keccak256.js';\nimport { decodeEventLog } from './decodeEventLog.js';\nimport { getAbiItem } from './getAbiItem.js';\n/**\n * Extracts & decodes logs matching the provided signature(s) (`abi` + optional `eventName`)\n * from a set of opaque logs.\n *\n * @param parameters - {@link ParseEventLogsParameters}\n * @returns The logs. {@link ParseEventLogsReturnType}\n *\n * @example\n * import { createClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { parseEventLogs } from 'viem/op-stack'\n *\n * const client = createClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const receipt = await getTransactionReceipt(client, {\n *   hash: '0xec23b2ba4bc59ba61554507c1b1bc91649e6586eb2dd00c728e8ed0db8bb37ea',\n * })\n *\n * const logs = parseEventLogs({ logs: receipt.logs })\n * // [{ args: { ... }, eventName: 'TransactionDeposited', ... }, ...]\n */\nexport function parseEventLogs(parameters) {\n  const {\n    abi,\n    args,\n    logs,\n    strict = true\n  } = parameters;\n  const eventName = (() => {\n    if (!parameters.eventName) return undefined;\n    if (Array.isArray(parameters.eventName)) return parameters.eventName;\n    return [parameters.eventName];\n  })();\n  return logs.map(log => {\n    try {\n      const abiItem = getAbiItem({\n        abi: abi,\n        name: log.topics[0]\n      });\n      if (!abiItem) return null;\n      const event = decodeEventLog({\n        ...log,\n        abi: [abiItem],\n        strict\n      });\n      // Check that the decoded event name matches the provided event name.\n      if (eventName && !eventName.includes(event.eventName)) return null;\n      // Check that the decoded event args match the provided args.\n      if (!includesArgs({\n        args: event.args,\n        inputs: abiItem.inputs,\n        matchArgs: args\n      })) return null;\n      return {\n        ...event,\n        ...log\n      };\n    } catch (err) {\n      let eventName;\n      let isUnnamed;\n      if (err instanceof AbiEventSignatureNotFoundError) return null;\n      if (err instanceof DecodeLogDataMismatch || err instanceof DecodeLogTopicsMismatch) {\n        // If strict mode is on, and log data/topics do not match event definition, skip.\n        if (strict) return null;\n        eventName = err.abiItem.name;\n        isUnnamed = err.abiItem.inputs?.some(x => !('name' in x && x.name));\n      }\n      // Set args to empty if there is an error decoding (e.g. indexed/non-indexed params mismatch).\n      return {\n        ...log,\n        args: isUnnamed ? [] : {},\n        eventName\n      };\n    }\n  }).filter(Boolean);\n}\nfunction includesArgs(parameters) {\n  const {\n    args,\n    inputs,\n    matchArgs\n  } = parameters;\n  if (!matchArgs) return true;\n  if (!args) return false;\n  function isEqual(input, value, arg) {\n    try {\n      if (input.type === 'address') return isAddressEqual(value, arg);\n      if (input.type === 'string' || input.type === 'bytes') return keccak256(toBytes(value)) === arg;\n      return value === arg;\n    } catch {\n      return false;\n    }\n  }\n  if (Array.isArray(args) && Array.isArray(matchArgs)) {\n    return matchArgs.every((value, index) => {\n      if (!value) return true;\n      const input = inputs[index];\n      if (!input) return false;\n      const value_ = Array.isArray(value) ? value : [value];\n      return value_.some(value => isEqual(input, value, args[index]));\n    });\n  }\n  if (typeof args === 'object' && !Array.isArray(args) && typeof matchArgs === 'object' && !Array.isArray(matchArgs)) return Object.entries(matchArgs).every(([key, value]) => {\n    if (!value) return true;\n    const input = inputs.find(input => input.name === key);\n    if (!input) return false;\n    const value_ = Array.isArray(value) ? value : [value];\n    return value_.some(value => isEqual(input, value, args[key]));\n  });\n  return false;\n}","map":{"version":3,"names":["AbiEventSignatureNotFoundError","DecodeLogDataMismatch","DecodeLogTopicsMismatch","isAddressEqual","toBytes","keccak256","decodeEventLog","getAbiItem","parseEventLogs","parameters","abi","args","logs","strict","eventName","undefined","Array","isArray","map","log","abiItem","name","topics","event","includes","includesArgs","inputs","matchArgs","err","isUnnamed","some","x","filter","Boolean","isEqual","input","value","arg","type","every","index","value_","Object","entries","key","find"],"sources":["/Users/siddharthpranay/Desktop/projects/Chirping/frontend/node_modules/viem/utils/abi/parseEventLogs.ts"],"sourcesContent":["// TODO(v3): checksum address.\n\nimport type { Abi, AbiEvent, AbiEventParameter, Address } from 'abitype'\nimport {\n  AbiEventSignatureNotFoundError,\n  DecodeLogDataMismatch,\n  DecodeLogTopicsMismatch,\n} from '../../errors/abi.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ContractEventName, GetEventArgs } from '../../types/contract.js'\nimport type { Log } from '../../types/log.js'\nimport type { RpcLog } from '../../types/rpc.js'\nimport { isAddressEqual } from '../address/isAddressEqual.js'\nimport { toBytes } from '../encoding/toBytes.js'\nimport { keccak256 } from '../hash/keccak256.js'\nimport {\n  type DecodeEventLogErrorType,\n  decodeEventLog,\n} from './decodeEventLog.js'\nimport { getAbiItem } from './getAbiItem.js'\n\nexport type ParseEventLogsParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  eventName extends\n    | ContractEventName<abi>\n    | ContractEventName<abi>[]\n    | undefined = ContractEventName<abi>,\n  strict extends boolean | undefined = boolean | undefined,\n  ///\n  allArgs = GetEventArgs<\n    abi,\n    eventName extends ContractEventName<abi>\n      ? eventName\n      : ContractEventName<abi>,\n    {\n      EnableUnion: true\n      IndexedOnly: false\n      Required: false\n    }\n  >,\n> = {\n  /** Contract ABI. */\n  abi: abi\n  /** Arguments for the event. */\n  args?: allArgs | undefined\n  /** Contract event. */\n  eventName?:\n    | eventName\n    | ContractEventName<abi>\n    | ContractEventName<abi>[]\n    | undefined\n  /** List of logs. */\n  logs: (Log | RpcLog)[]\n  strict?: strict | boolean | undefined\n}\n\nexport type ParseEventLogsReturnType<\n  abi extends Abi | readonly unknown[] = Abi,\n  eventName extends\n    | ContractEventName<abi>\n    | ContractEventName<abi>[]\n    | undefined = ContractEventName<abi>,\n  strict extends boolean | undefined = boolean | undefined,\n  ///\n  derivedEventName extends\n    | ContractEventName<abi>\n    | undefined = eventName extends ContractEventName<abi>[]\n    ? eventName[number]\n    : eventName,\n> = Log<bigint, number, false, undefined, strict, abi, derivedEventName>[]\n\nexport type ParseEventLogsErrorType = DecodeEventLogErrorType | ErrorType\n\n/**\n * Extracts & decodes logs matching the provided signature(s) (`abi` + optional `eventName`)\n * from a set of opaque logs.\n *\n * @param parameters - {@link ParseEventLogsParameters}\n * @returns The logs. {@link ParseEventLogsReturnType}\n *\n * @example\n * import { createClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { parseEventLogs } from 'viem/op-stack'\n *\n * const client = createClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const receipt = await getTransactionReceipt(client, {\n *   hash: '0xec23b2ba4bc59ba61554507c1b1bc91649e6586eb2dd00c728e8ed0db8bb37ea',\n * })\n *\n * const logs = parseEventLogs({ logs: receipt.logs })\n * // [{ args: { ... }, eventName: 'TransactionDeposited', ... }, ...]\n */\nexport function parseEventLogs<\n  abi extends Abi | readonly unknown[],\n  strict extends boolean | undefined = true,\n  eventName extends\n    | ContractEventName<abi>\n    | ContractEventName<abi>[]\n    | undefined = undefined,\n>(\n  parameters: ParseEventLogsParameters<abi, eventName, strict>,\n): ParseEventLogsReturnType<abi, eventName, strict> {\n  const { abi, args, logs, strict = true } = parameters\n\n  const eventName = (() => {\n    if (!parameters.eventName) return undefined\n    if (Array.isArray(parameters.eventName)) return parameters.eventName\n    return [parameters.eventName as string]\n  })()\n\n  return logs\n    .map((log) => {\n      try {\n        const abiItem = getAbiItem({\n          abi: abi as Abi,\n          name: log.topics[0] as string,\n        }) as AbiEvent\n        if (!abiItem) return null\n\n        const event = decodeEventLog({\n          ...log,\n          abi: [abiItem],\n          strict,\n        })\n\n        // Check that the decoded event name matches the provided event name.\n        if (eventName && !eventName.includes(event.eventName)) return null\n\n        // Check that the decoded event args match the provided args.\n        if (\n          !includesArgs({\n            args: event.args,\n            inputs: abiItem.inputs,\n            matchArgs: args,\n          })\n        )\n          return null\n\n        return { ...event, ...log }\n      } catch (err) {\n        let eventName: string | undefined\n        let isUnnamed: boolean | undefined\n\n        if (err instanceof AbiEventSignatureNotFoundError) return null\n        if (\n          err instanceof DecodeLogDataMismatch ||\n          err instanceof DecodeLogTopicsMismatch\n        ) {\n          // If strict mode is on, and log data/topics do not match event definition, skip.\n          if (strict) return null\n          eventName = err.abiItem.name\n          isUnnamed = err.abiItem.inputs?.some((x) => !('name' in x && x.name))\n        }\n\n        // Set args to empty if there is an error decoding (e.g. indexed/non-indexed params mismatch).\n        return { ...log, args: isUnnamed ? [] : {}, eventName }\n      }\n    })\n    .filter(Boolean) as unknown as ParseEventLogsReturnType<\n    abi,\n    eventName,\n    strict\n  >\n}\n\nfunction includesArgs(parameters: {\n  args: unknown\n  inputs: AbiEvent['inputs']\n  matchArgs: unknown\n}) {\n  const { args, inputs, matchArgs } = parameters\n\n  if (!matchArgs) return true\n  if (!args) return false\n\n  function isEqual(input: AbiEventParameter, value: unknown, arg: unknown) {\n    try {\n      if (input.type === 'address')\n        return isAddressEqual(value as Address, arg as Address)\n      if (input.type === 'string' || input.type === 'bytes')\n        return keccak256(toBytes(value as string)) === arg\n      return value === arg\n    } catch {\n      return false\n    }\n  }\n\n  if (Array.isArray(args) && Array.isArray(matchArgs)) {\n    return matchArgs.every((value, index) => {\n      if (!value) return true\n      const input = inputs[index]\n      if (!input) return false\n      const value_ = Array.isArray(value) ? value : [value]\n      return value_.some((value) => isEqual(input, value, args[index]))\n    })\n  }\n\n  if (\n    typeof args === 'object' &&\n    !Array.isArray(args) &&\n    typeof matchArgs === 'object' &&\n    !Array.isArray(matchArgs)\n  )\n    return Object.entries(matchArgs).every(([key, value]) => {\n      if (!value) return true\n      const input = inputs.find((input) => input.name === key)\n      if (!input) return false\n      const value_ = Array.isArray(value) ? value : [value]\n      return value_.some((value) =>\n        isEqual(input, value, (args as Record<string, unknown>)[key]),\n      )\n    })\n\n  return false\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}