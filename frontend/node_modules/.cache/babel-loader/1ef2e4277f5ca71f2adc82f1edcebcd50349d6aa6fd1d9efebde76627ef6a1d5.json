{"ast":null,"code":"let isReconnecting = false;\n/** https://wagmi.sh/core/api/actions/reconnect */\nexport async function reconnect(config) {\n  let parameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  // If already reconnecting, do nothing\n  if (isReconnecting) return [];\n  isReconnecting = true;\n  config.setState(x => ({\n    ...x,\n    status: x.current ? 'reconnecting' : 'connecting'\n  }));\n  const connectors = [];\n  if (parameters.connectors?.length) {\n    for (const connector_ of parameters.connectors) {\n      let connector;\n      // \"Register\" connector if not already created\n      if (typeof connector_ === 'function') connector = config._internal.connectors.setup(connector_);else connector = connector_;\n      connectors.push(connector);\n    }\n  } else connectors.push(...config.connectors);\n  // Try recently-used connectors first\n  let recentConnectorId;\n  try {\n    recentConnectorId = await config.storage?.getItem('recentConnectorId');\n  } catch {}\n  const scores = {};\n  for (const [, connection] of config.state.connections) {\n    scores[connection.connector.id] = 1;\n  }\n  if (recentConnectorId) scores[recentConnectorId] = 0;\n  const sorted = Object.keys(scores).length > 0 ?\n  // .toSorted()\n  [...connectors].sort((a, b) => (scores[a.id] ?? 10) - (scores[b.id] ?? 10)) : connectors;\n  // Iterate through each connector and try to connect\n  let connected = false;\n  const connections = [];\n  const providers = [];\n  for (const connector of sorted) {\n    const provider = await connector.getProvider().catch(() => undefined);\n    if (!provider) continue;\n    // If we already have an instance of this connector's provider,\n    // then we have already checked it (ie. injected connectors can\n    // share the same `window.ethereum` instance, so we don't want to\n    // connect to it again).\n    if (providers.some(x => x === provider)) continue;\n    const isAuthorized = await connector.isAuthorized();\n    if (!isAuthorized) continue;\n    const data = await connector.connect({\n      isReconnecting: true\n    }).catch(() => null);\n    if (!data) continue;\n    connector.emitter.off('connect', config._internal.events.connect);\n    connector.emitter.on('change', config._internal.events.change);\n    connector.emitter.on('disconnect', config._internal.events.disconnect);\n    config.setState(x => {\n      const connections = new Map(connected ? x.connections : new Map()).set(connector.uid, {\n        accounts: data.accounts,\n        chainId: data.chainId,\n        connector\n      });\n      return {\n        ...x,\n        current: connected ? x.current : connector.uid,\n        connections\n      };\n    });\n    connections.push({\n      accounts: data.accounts,\n      chainId: data.chainId,\n      connector\n    });\n    providers.push(provider);\n    connected = true;\n  }\n  // Prevent overwriting connected status from race condition\n  if (config.state.status === 'reconnecting' || config.state.status === 'connecting') {\n    // If connecting didn't succeed, set to disconnected\n    if (!connected) config.setState(x => ({\n      ...x,\n      connections: new Map(),\n      current: null,\n      status: 'disconnected'\n    }));else config.setState(x => ({\n      ...x,\n      status: 'connected'\n    }));\n  }\n  isReconnecting = false;\n  return connections;\n}","map":{"version":3,"names":["isReconnecting","reconnect","config","parameters","arguments","length","undefined","setState","x","status","current","connectors","connector_","connector","_internal","setup","push","recentConnectorId","storage","getItem","scores","connection","state","connections","id","sorted","Object","keys","sort","a","b","connected","providers","provider","getProvider","catch","some","isAuthorized","data","connect","emitter","off","events","on","change","disconnect","Map","set","uid","accounts","chainId"],"sources":["/Users/siddharthpranay/Desktop/projects/Chirping/frontend/node_modules/@wagmi/core/src/actions/reconnect.ts"],"sourcesContent":["import type { Address } from 'viem'\n\nimport type { CreateConnectorFn } from '../connectors/createConnector.js'\nimport type { Config, Connection, Connector } from '../createConfig.js'\nimport type { ErrorType } from '../errors/base.js'\nimport type { Compute } from '../types/utils.js'\n\nexport type ReconnectParameters = {\n  /** Connectors to attempt reconnect with */\n  connectors?: readonly (CreateConnectorFn | Connector)[] | undefined\n}\n\nexport type ReconnectReturnType = Compute<Connection>[]\n\nexport type ReconnectErrorType = ErrorType\n\nlet isReconnecting = false\n\n/** https://wagmi.sh/core/api/actions/reconnect */\nexport async function reconnect(\n  config: Config,\n  parameters: ReconnectParameters = {},\n): Promise<ReconnectReturnType> {\n  // If already reconnecting, do nothing\n  if (isReconnecting) return []\n  isReconnecting = true\n\n  config.setState((x) => ({\n    ...x,\n    status: x.current ? 'reconnecting' : 'connecting',\n  }))\n\n  const connectors: Connector[] = []\n  if (parameters.connectors?.length) {\n    for (const connector_ of parameters.connectors) {\n      let connector: Connector\n      // \"Register\" connector if not already created\n      if (typeof connector_ === 'function')\n        connector = config._internal.connectors.setup(connector_)\n      else connector = connector_\n      connectors.push(connector)\n    }\n  } else connectors.push(...config.connectors)\n\n  // Try recently-used connectors first\n  let recentConnectorId: string | null | undefined\n  try {\n    recentConnectorId = await config.storage?.getItem('recentConnectorId')\n  } catch {}\n  const scores: Record<string, number> = {}\n  for (const [, connection] of config.state.connections) {\n    scores[connection.connector.id] = 1\n  }\n  if (recentConnectorId) scores[recentConnectorId] = 0\n  const sorted =\n    Object.keys(scores).length > 0\n      ? // .toSorted()\n        [...connectors].sort(\n          (a, b) => (scores[a.id] ?? 10) - (scores[b.id] ?? 10),\n        )\n      : connectors\n\n  // Iterate through each connector and try to connect\n  let connected = false\n  const connections: Connection[] = []\n  const providers: unknown[] = []\n  for (const connector of sorted) {\n    const provider = await connector.getProvider().catch(() => undefined)\n    if (!provider) continue\n\n    // If we already have an instance of this connector's provider,\n    // then we have already checked it (ie. injected connectors can\n    // share the same `window.ethereum` instance, so we don't want to\n    // connect to it again).\n    if (providers.some((x) => x === provider)) continue\n\n    const isAuthorized = await connector.isAuthorized()\n    if (!isAuthorized) continue\n\n    const data = await connector\n      .connect({ isReconnecting: true })\n      .catch(() => null)\n    if (!data) continue\n\n    connector.emitter.off('connect', config._internal.events.connect)\n    connector.emitter.on('change', config._internal.events.change)\n    connector.emitter.on('disconnect', config._internal.events.disconnect)\n\n    config.setState((x) => {\n      const connections = new Map(connected ? x.connections : new Map()).set(\n        connector.uid,\n        { accounts: data.accounts, chainId: data.chainId, connector },\n      )\n      return {\n        ...x,\n        current: connected ? x.current : connector.uid,\n        connections,\n      }\n    })\n    connections.push({\n      accounts: data.accounts as readonly [Address, ...Address[]],\n      chainId: data.chainId,\n      connector,\n    })\n    providers.push(provider)\n    connected = true\n  }\n\n  // Prevent overwriting connected status from race condition\n  if (\n    config.state.status === 'reconnecting' ||\n    config.state.status === 'connecting'\n  ) {\n    // If connecting didn't succeed, set to disconnected\n    if (!connected)\n      config.setState((x) => ({\n        ...x,\n        connections: new Map(),\n        current: null,\n        status: 'disconnected',\n      }))\n    else config.setState((x) => ({ ...x, status: 'connected' }))\n  }\n\n  isReconnecting = false\n  return connections\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}