{"ast":null,"code":"import { createClient, custom } from 'viem';\nimport { getAddress, parseAccount } from 'viem/utils';\nimport { ConnectorAccountNotFoundError, ConnectorChainMismatchError, ConnectorNotConnectedError } from '../errors/config.js';\n/** https://wagmi.sh/core/api/actions/getConnectorClient */\nexport async function getConnectorClient(config, parameters = {}) {\n  // Get connection\n  let connection;\n  if (parameters.connector) {\n    const {\n      connector\n    } = parameters;\n    const [accounts, chainId] = await Promise.all([connector.getAccounts(), connector.getChainId()]);\n    connection = {\n      accounts: accounts,\n      chainId,\n      connector\n    };\n  } else connection = config.state.connections.get(config.state.current);\n  if (!connection) throw new ConnectorNotConnectedError();\n  const chainId = parameters.chainId ?? connection.chainId;\n  // Check connector using same chainId as connection\n  const connectorChainId = await connection.connector.getChainId();\n  if (connectorChainId !== connection.chainId) throw new ConnectorChainMismatchError({\n    connectionChainId: connection.chainId,\n    connectorChainId\n  });\n  const connector = connection.connector;\n  if (connector.getClient) return connector.getClient({\n    chainId\n  });\n  // Default using `custom` transport\n  const account = parseAccount(parameters.account ?? connection.accounts[0]);\n  account.address = getAddress(account.address); // TODO: Checksum address as part of `parseAccount`?\n  const chain = config.chains.find(chain => chain.id === chainId);\n  const provider = await connection.connector.getProvider({\n    chainId\n  });\n  // If account was provided, check that it exists on the connector\n  if (parameters.account && !connection.accounts.some(x => x.toLowerCase() === account.address.toLowerCase())) throw new ConnectorAccountNotFoundError({\n    address: account.address,\n    connector\n  });\n  return createClient({\n    account,\n    chain,\n    name: 'Connector Client',\n    transport: opts => custom(provider)({\n      ...opts,\n      retryCount: 0\n    })\n  });\n}","map":{"version":3,"names":["createClient","custom","getAddress","parseAccount","ConnectorAccountNotFoundError","ConnectorChainMismatchError","ConnectorNotConnectedError","getConnectorClient","config","parameters","connection","connector","accounts","chainId","Promise","all","getAccounts","getChainId","state","connections","get","current","connectorChainId","connectionChainId","getClient","account","address","chain","chains","find","id","provider","getProvider","some","x","toLowerCase","name","transport","opts","retryCount"],"sources":["/Users/siddharthpranay/Desktop/projects/Chirping/frontend/node_modules/@wagmi/core/src/actions/getConnectorClient.ts"],"sourcesContent":["import {\n  type Account,\n  type Address,\n  type BaseErrorType,\n  type Client,\n  createClient,\n  custom,\n} from 'viem'\nimport { getAddress, parseAccount } from 'viem/utils'\n\nimport type { Config, Connection } from '../createConfig.js'\nimport type { ErrorType } from '../errors/base.js'\nimport {\n  ConnectorAccountNotFoundError,\n  type ConnectorAccountNotFoundErrorType,\n  ConnectorChainMismatchError,\n  type ConnectorChainMismatchErrorType,\n  ConnectorNotConnectedError,\n  type ConnectorNotConnectedErrorType,\n} from '../errors/config.js'\nimport type {\n  ChainIdParameter,\n  ConnectorParameter,\n} from '../types/properties.js'\nimport type { Compute } from '../types/utils.js'\n\nexport type GetConnectorClientParameters<\n  config extends Config = Config,\n  chainId extends\n    config['chains'][number]['id'] = config['chains'][number]['id'],\n> = Compute<\n  ChainIdParameter<config, chainId> &\n    ConnectorParameter & {\n      account?: Address | Account | undefined\n    }\n>\n\nexport type GetConnectorClientReturnType<\n  config extends Config = Config,\n  chainId extends\n    config['chains'][number]['id'] = config['chains'][number]['id'],\n> = Compute<\n  Client<\n    config['_internal']['transports'][chainId],\n    Extract<config['chains'][number], { id: chainId }>,\n    Account\n  >\n>\n\nexport type GetConnectorClientErrorType =\n  | ConnectorAccountNotFoundErrorType\n  | ConnectorChainMismatchErrorType\n  | ConnectorNotConnectedErrorType\n  // base\n  | BaseErrorType\n  | ErrorType\n\n/** https://wagmi.sh/core/api/actions/getConnectorClient */\nexport async function getConnectorClient<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n>(\n  config: config,\n  parameters: GetConnectorClientParameters<config, chainId> = {},\n): Promise<GetConnectorClientReturnType<config, chainId>> {\n  // Get connection\n  let connection: Connection | undefined\n  if (parameters.connector) {\n    const { connector } = parameters\n    const [accounts, chainId] = await Promise.all([\n      connector.getAccounts(),\n      connector.getChainId(),\n    ])\n    connection = {\n      accounts: accounts as readonly [Address, ...Address[]],\n      chainId,\n      connector,\n    }\n  } else connection = config.state.connections.get(config.state.current!)\n  if (!connection) throw new ConnectorNotConnectedError()\n\n  const chainId = parameters.chainId ?? connection.chainId\n\n  // Check connector using same chainId as connection\n  const connectorChainId = await connection.connector.getChainId()\n  if (connectorChainId !== connection.chainId)\n    throw new ConnectorChainMismatchError({\n      connectionChainId: connection.chainId,\n      connectorChainId,\n    })\n\n  // If connector has custom `getClient` implementation\n  type Return = GetConnectorClientReturnType<config, chainId>\n  const connector = connection.connector\n  if (connector.getClient)\n    return connector.getClient({ chainId }) as unknown as Return\n\n  // Default using `custom` transport\n  const account = parseAccount(parameters.account ?? connection.accounts[0]!)\n  account.address = getAddress(account.address) // TODO: Checksum address as part of `parseAccount`?\n\n  const chain = config.chains.find((chain) => chain.id === chainId)\n  const provider = (await connection.connector.getProvider({ chainId })) as {\n    request(...args: any): Promise<any>\n  }\n\n  // If account was provided, check that it exists on the connector\n  if (\n    parameters.account &&\n    !connection.accounts.some(\n      (x) => x.toLowerCase() === account.address.toLowerCase(),\n    )\n  )\n    throw new ConnectorAccountNotFoundError({\n      address: account.address,\n      connector,\n    })\n\n  return createClient({\n    account,\n    chain,\n    name: 'Connector Client',\n    transport: (opts) => custom(provider)({ ...opts, retryCount: 0 }),\n  }) as Return\n}\n"],"mappings":"AAAA,SAKEA,YAAY,EACZC,MAAM,QACD,MAAM;AACb,SAASC,UAAU,EAAEC,YAAY,QAAQ,YAAY;AAIrD,SACEC,6BAA6B,EAE7BC,2BAA2B,EAE3BC,0BAA0B,QAErB,qBAAqB;AAsC5B;AACA,OAAO,eAAeC,kBAAkBA,CAItCC,MAAc,EACdC,UAAA,GAA4D,EAAE;EAE9D;EACA,IAAIC,UAAkC;EACtC,IAAID,UAAU,CAACE,SAAS,EAAE;IACxB,MAAM;MAAEA;IAAS,CAAE,GAAGF,UAAU;IAChC,MAAM,CAACG,QAAQ,EAAEC,OAAO,CAAC,GAAG,MAAMC,OAAO,CAACC,GAAG,CAAC,CAC5CJ,SAAS,CAACK,WAAW,EAAE,EACvBL,SAAS,CAACM,UAAU,EAAE,CACvB,CAAC;IACFP,UAAU,GAAG;MACXE,QAAQ,EAAEA,QAA4C;MACtDC,OAAO;MACPF;KACD;EACH,CAAC,MAAMD,UAAU,GAAGF,MAAM,CAACU,KAAK,CAACC,WAAW,CAACC,GAAG,CAACZ,MAAM,CAACU,KAAK,CAACG,OAAQ,CAAC;EACvE,IAAI,CAACX,UAAU,EAAE,MAAM,IAAIJ,0BAA0B,EAAE;EAEvD,MAAMO,OAAO,GAAGJ,UAAU,CAACI,OAAO,IAAIH,UAAU,CAACG,OAAO;EAExD;EACA,MAAMS,gBAAgB,GAAG,MAAMZ,UAAU,CAACC,SAAS,CAACM,UAAU,EAAE;EAChE,IAAIK,gBAAgB,KAAKZ,UAAU,CAACG,OAAO,EACzC,MAAM,IAAIR,2BAA2B,CAAC;IACpCkB,iBAAiB,EAAEb,UAAU,CAACG,OAAO;IACrCS;GACD,CAAC;EAIJ,MAAMX,SAAS,GAAGD,UAAU,CAACC,SAAS;EACtC,IAAIA,SAAS,CAACa,SAAS,EACrB,OAAOb,SAAS,CAACa,SAAS,CAAC;IAAEX;EAAO,CAAE,CAAsB;EAE9D;EACA,MAAMY,OAAO,GAAGtB,YAAY,CAACM,UAAU,CAACgB,OAAO,IAAIf,UAAU,CAACE,QAAQ,CAAC,CAAC,CAAE,CAAC;EAC3Ea,OAAO,CAACC,OAAO,GAAGxB,UAAU,CAACuB,OAAO,CAACC,OAAO,CAAC,EAAC;EAE9C,MAAMC,KAAK,GAAGnB,MAAM,CAACoB,MAAM,CAACC,IAAI,CAAEF,KAAK,IAAKA,KAAK,CAACG,EAAE,KAAKjB,OAAO,CAAC;EACjE,MAAMkB,QAAQ,GAAI,MAAMrB,UAAU,CAACC,SAAS,CAACqB,WAAW,CAAC;IAAEnB;EAAO,CAAE,CAEnE;EAED;EACA,IACEJ,UAAU,CAACgB,OAAO,IAClB,CAACf,UAAU,CAACE,QAAQ,CAACqB,IAAI,CACtBC,CAAC,IAAKA,CAAC,CAACC,WAAW,EAAE,KAAKV,OAAO,CAACC,OAAO,CAACS,WAAW,EAAE,CACzD,EAED,MAAM,IAAI/B,6BAA6B,CAAC;IACtCsB,OAAO,EAAED,OAAO,CAACC,OAAO;IACxBf;GACD,CAAC;EAEJ,OAAOX,YAAY,CAAC;IAClByB,OAAO;IACPE,KAAK;IACLS,IAAI,EAAE,kBAAkB;IACxBC,SAAS,EAAGC,IAAI,IAAKrC,MAAM,CAAC8B,QAAQ,CAAC,CAAC;MAAE,GAAGO,IAAI;MAAEC,UAAU,EAAE;IAAC,CAAE;GACjE,CAAW;AACd","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}