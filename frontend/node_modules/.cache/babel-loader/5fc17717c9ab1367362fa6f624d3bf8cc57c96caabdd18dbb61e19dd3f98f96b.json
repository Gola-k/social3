{"ast":null,"code":"import { ChainDisconnectedError, ProviderDisconnectedError, createTransport, hexToNumber, withRetry, withTimeout } from 'viem';\nexport function unstable_connector(connector) {\n  let config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    type\n  } = connector;\n  const {\n    key = 'connector',\n    name = 'Connector',\n    retryDelay\n  } = config;\n  return parameters => {\n    const {\n      chain,\n      connectors\n    } = parameters;\n    const retryCount = config.retryCount ?? parameters.retryCount;\n    const request = async _ref => {\n      let {\n        method,\n        params\n      } = _ref;\n      const connector = connectors?.getState().find(c => c.type === type);\n      if (!connector) throw new ProviderDisconnectedError(new Error(`Could not find connector of type \"${type}\" in \\`connectors\\` passed to \\`createConfig\\`.`));\n      const provider = await connector.getProvider({\n        chainId: chain?.id\n      });\n      if (!provider) throw new ProviderDisconnectedError(new Error('Provider is disconnected.'));\n      // We are applying a retry & timeout strategy here as some injected wallets (e.g. MetaMask) fail to\n      // immediately resolve a JSON-RPC request on page load.\n      const chainId = hexToNumber(await withRetry(() => withTimeout(() => provider.request({\n        method: 'eth_chainId'\n      }), {\n        timeout: 100\n      })));\n      if (chain && chainId !== chain.id) throw new ChainDisconnectedError(new Error(`The current chain of the connector (id: ${chainId}) does not match the target chain for the request (id: ${chain.id} – ${chain.name}).`));\n      const body = {\n        method,\n        params\n      };\n      return provider.request(body);\n    };\n    return createTransport({\n      key,\n      name,\n      request,\n      retryCount,\n      retryDelay,\n      type: 'connector'\n    });\n  };\n}","map":{"version":3,"names":["ChainDisconnectedError","ProviderDisconnectedError","createTransport","hexToNumber","withRetry","withTimeout","unstable_connector","connector","config","arguments","length","undefined","type","key","name","retryDelay","parameters","chain","connectors","retryCount","request","_ref","method","params","getState","find","c","Error","provider","getProvider","chainId","id","timeout","body"],"sources":["/Users/siddharthpranay/Desktop/projects/Chirping/frontend/node_modules/@wagmi/core/src/transports/connector.ts"],"sourcesContent":["import {\n  ChainDisconnectedError,\n  type EIP1193Parameters,\n  type EIP1193Provider,\n  type EIP1193RequestFn,\n  ProviderDisconnectedError,\n  type TransportConfig,\n  type WalletRpcSchema,\n  createTransport,\n  hexToNumber,\n  withRetry,\n  withTimeout,\n} from 'viem'\n\nimport type { Connector, Transport } from '../createConfig.js'\n\nexport type ConnectorTransportConfig = {\n  /** The key of the transport. */\n  key?: TransportConfig['key'] | undefined\n  /** The name of the transport. */\n  name?: TransportConfig['name'] | undefined\n  /** The max number of times to retry. */\n  retryCount?: TransportConfig['retryCount'] | undefined\n  /** The base delay (in ms) between retries. */\n  retryDelay?: TransportConfig['retryDelay'] | undefined\n}\n\nexport type ConnectorTransport = Transport\n\nexport function unstable_connector(\n  connector: Pick<Connector, 'type'>,\n  config: ConnectorTransportConfig = {},\n): Transport<'connector'> {\n  const { type } = connector\n  const { key = 'connector', name = 'Connector', retryDelay } = config\n\n  return (parameters) => {\n    const { chain, connectors } = parameters\n    const retryCount = config.retryCount ?? parameters.retryCount\n\n    const request: EIP1193RequestFn = async ({ method, params }) => {\n      const connector = connectors?.getState().find((c) => c.type === type)\n      if (!connector)\n        throw new ProviderDisconnectedError(\n          new Error(\n            `Could not find connector of type \"${type}\" in \\`connectors\\` passed to \\`createConfig\\`.`,\n          ),\n        )\n\n      const provider = (await connector.getProvider({\n        chainId: chain?.id,\n      })) as EIP1193Provider | undefined\n      if (!provider)\n        throw new ProviderDisconnectedError(\n          new Error('Provider is disconnected.'),\n        )\n\n      // We are applying a retry & timeout strategy here as some injected wallets (e.g. MetaMask) fail to\n      // immediately resolve a JSON-RPC request on page load.\n      const chainId = hexToNumber(\n        await withRetry(() =>\n          withTimeout(() => provider.request({ method: 'eth_chainId' }), {\n            timeout: 100,\n          }),\n        ),\n      )\n      if (chain && chainId !== chain.id)\n        throw new ChainDisconnectedError(\n          new Error(\n            `The current chain of the connector (id: ${chainId}) does not match the target chain for the request (id: ${chain.id} – ${chain.name}).`,\n          ),\n        )\n\n      const body = { method, params } as EIP1193Parameters<WalletRpcSchema>\n      return provider.request(body)\n    }\n\n    return createTransport({\n      key,\n      name,\n      request,\n      retryCount,\n      retryDelay,\n      type: 'connector',\n    })\n  }\n}\n"],"mappings":"AAAA,SACEA,sBAAsB,EAItBC,yBAAyB,EAGzBC,eAAe,EACfC,WAAW,EACXC,SAAS,EACTC,WAAW,QACN,MAAM;AAiBb,OAAM,SAAUC,kBAAkBA,CAChCC,SAAkC,EACG;EAAA,IAArCC,MAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAmC,EAAE;EAErC,MAAM;IAAEG;EAAI,CAAE,GAAGL,SAAS;EAC1B,MAAM;IAAEM,GAAG,GAAG,WAAW;IAAEC,IAAI,GAAG,WAAW;IAAEC;EAAU,CAAE,GAAGP,MAAM;EAEpE,OAAQQ,UAAU,IAAI;IACpB,MAAM;MAAEC,KAAK;MAAEC;IAAU,CAAE,GAAGF,UAAU;IACxC,MAAMG,UAAU,GAAGX,MAAM,CAACW,UAAU,IAAIH,UAAU,CAACG,UAAU;IAE7D,MAAMC,OAAO,GAAqB,MAAAC,IAAA,IAA6B;MAAA,IAAtB;QAAEC,MAAM;QAAEC;MAAM,CAAE,GAAAF,IAAA;MACzD,MAAMd,SAAS,GAAGW,UAAU,EAAEM,QAAQ,EAAE,CAACC,IAAI,CAAEC,CAAC,IAAKA,CAAC,CAACd,IAAI,KAAKA,IAAI,CAAC;MACrE,IAAI,CAACL,SAAS,EACZ,MAAM,IAAIN,yBAAyB,CACjC,IAAI0B,KAAK,CACP,qCAAqCf,IAAI,iDAAiD,CAC3F,CACF;MAEH,MAAMgB,QAAQ,GAAI,MAAMrB,SAAS,CAACsB,WAAW,CAAC;QAC5CC,OAAO,EAAEb,KAAK,EAAEc;OACjB,CAAiC;MAClC,IAAI,CAACH,QAAQ,EACX,MAAM,IAAI3B,yBAAyB,CACjC,IAAI0B,KAAK,CAAC,2BAA2B,CAAC,CACvC;MAEH;MACA;MACA,MAAMG,OAAO,GAAG3B,WAAW,CACzB,MAAMC,SAAS,CAAC,MACdC,WAAW,CAAC,MAAMuB,QAAQ,CAACR,OAAO,CAAC;QAAEE,MAAM,EAAE;MAAa,CAAE,CAAC,EAAE;QAC7DU,OAAO,EAAE;OACV,CAAC,CACH,CACF;MACD,IAAIf,KAAK,IAAIa,OAAO,KAAKb,KAAK,CAACc,EAAE,EAC/B,MAAM,IAAI/B,sBAAsB,CAC9B,IAAI2B,KAAK,CACP,2CAA2CG,OAAO,0DAA0Db,KAAK,CAACc,EAAE,MAAMd,KAAK,CAACH,IAAI,IAAI,CACzI,CACF;MAEH,MAAMmB,IAAI,GAAG;QAAEX,MAAM;QAAEC;MAAM,CAAwC;MACrE,OAAOK,QAAQ,CAACR,OAAO,CAACa,IAAI,CAAC;IAC/B,CAAC;IAED,OAAO/B,eAAe,CAAC;MACrBW,GAAG;MACHC,IAAI;MACJM,OAAO;MACPD,UAAU;MACVJ,UAAU;MACVH,IAAI,EAAE;KACP,CAAC;EACJ,CAAC;AACH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}