{"ast":null,"code":"import { RpcRequestError, SwitchChainError, UserRejectedRequestError, custom, fromHex, getAddress, keccak256, numberToHex, stringToHex } from 'viem';\nimport { rpc } from 'viem/utils';\nimport { ChainNotConfiguredError, ConnectorNotConnectedError } from '../errors/config.js';\nimport { createConnector } from './createConnector.js';\nmock.type = 'mock';\nexport function mock(parameters) {\n  const transactionCache = new Map();\n  const features = parameters.features ?? {};\n  let connected = false;\n  let connectedChainId;\n  return createConnector(config => ({\n    id: 'mock',\n    name: 'Mock Connector',\n    type: mock.type,\n    async setup() {\n      connectedChainId = config.chains[0].id;\n    },\n    async connect() {\n      let {\n        chainId\n      } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      if (features.connectError) {\n        if (typeof features.connectError === 'boolean') throw new UserRejectedRequestError(new Error('Failed to connect.'));\n        throw features.connectError;\n      }\n      const provider = await this.getProvider();\n      const accounts = await provider.request({\n        method: 'eth_requestAccounts'\n      });\n      let currentChainId = await this.getChainId();\n      if (chainId && currentChainId !== chainId) {\n        const chain = await this.switchChain({\n          chainId\n        });\n        currentChainId = chain.id;\n      }\n      connected = true;\n      return {\n        accounts: accounts.map(x => getAddress(x)),\n        chainId: currentChainId\n      };\n    },\n    async disconnect() {\n      connected = false;\n    },\n    async getAccounts() {\n      if (!connected) throw new ConnectorNotConnectedError();\n      const provider = await this.getProvider();\n      const accounts = await provider.request({\n        method: 'eth_accounts'\n      });\n      return accounts.map(x => getAddress(x));\n    },\n    async getChainId() {\n      const provider = await this.getProvider();\n      const hexChainId = await provider.request({\n        method: 'eth_chainId'\n      });\n      return fromHex(hexChainId, 'number');\n    },\n    async isAuthorized() {\n      if (!features.reconnect) return false;\n      if (!connected) return false;\n      const accounts = await this.getAccounts();\n      return !!accounts.length;\n    },\n    async switchChain(_ref) {\n      let {\n        chainId\n      } = _ref;\n      const provider = await this.getProvider();\n      const chain = config.chains.find(x => x.id === chainId);\n      if (!chain) throw new SwitchChainError(new ChainNotConfiguredError());\n      await provider.request({\n        method: 'wallet_switchEthereumChain',\n        params: [{\n          chainId: numberToHex(chainId)\n        }]\n      });\n      return chain;\n    },\n    onAccountsChanged(accounts) {\n      if (accounts.length === 0) this.onDisconnect();else config.emitter.emit('change', {\n        accounts: accounts.map(x => getAddress(x))\n      });\n    },\n    onChainChanged(chain) {\n      const chainId = Number(chain);\n      config.emitter.emit('change', {\n        chainId\n      });\n    },\n    async onDisconnect(_error) {\n      config.emitter.emit('disconnect');\n      connected = false;\n    },\n    async getProvider() {\n      let {\n        chainId\n      } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      const chain = config.chains.find(x => x.id === chainId) ?? config.chains[0];\n      const url = chain.rpcUrls.default.http[0];\n      const request = async _ref2 => {\n        let {\n          method,\n          params\n        } = _ref2;\n        // eth methods\n        if (method === 'eth_chainId') return numberToHex(connectedChainId);\n        if (method === 'eth_requestAccounts') return parameters.accounts;\n        if (method === 'eth_signTypedData_v4') if (features.signTypedDataError) {\n          if (typeof features.signTypedDataError === 'boolean') throw new UserRejectedRequestError(new Error('Failed to sign typed data.'));\n          throw features.signTypedDataError;\n        }\n        // wallet methods\n        if (method === 'wallet_switchEthereumChain') {\n          if (features.switchChainError) {\n            if (typeof features.switchChainError === 'boolean') throw new UserRejectedRequestError(new Error('Failed to switch chain.'));\n            throw features.switchChainError;\n          }\n          connectedChainId = fromHex(params[0].chainId, 'number');\n          this.onChainChanged(connectedChainId.toString());\n          return;\n        }\n        if (method === 'wallet_watchAsset') {\n          if (features.watchAssetError) {\n            if (typeof features.watchAssetError === 'boolean') throw new UserRejectedRequestError(new Error('Failed to switch chain.'));\n            throw features.watchAssetError;\n          }\n          return connected;\n        }\n        if (method === 'wallet_getCapabilities') return {\n          '0x2105': {\n            paymasterService: {\n              supported: params[0] === '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266'\n            },\n            sessionKeys: {\n              supported: true\n            }\n          },\n          '0x14A34': {\n            paymasterService: {\n              supported: params[0] === '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266'\n            }\n          }\n        };\n        if (method === 'wallet_sendCalls') {\n          const hashes = [];\n          const calls = params[0].calls;\n          for (const call of calls) {\n            const {\n              result,\n              error\n            } = await rpc.http(url, {\n              body: {\n                method: 'eth_sendTransaction',\n                params: [call]\n              }\n            });\n            if (error) throw new RpcRequestError({\n              body: {\n                method,\n                params\n              },\n              error,\n              url\n            });\n            hashes.push(result);\n          }\n          const id = keccak256(stringToHex(JSON.stringify(calls)));\n          transactionCache.set(id, hashes);\n          return id;\n        }\n        if (method === 'wallet_getCallsStatus') {\n          const hashes = transactionCache.get(params[0]);\n          if (!hashes) return null;\n          const receipts = await Promise.all(hashes.map(async hash => {\n            const {\n              result,\n              error\n            } = await rpc.http(url, {\n              body: {\n                method: 'eth_getTransactionReceipt',\n                params: [hash],\n                id: 0\n              }\n            });\n            if (error) throw new RpcRequestError({\n              body: {\n                method,\n                params\n              },\n              error,\n              url\n            });\n            if (!result) return null;\n            return {\n              blockHash: result.blockHash,\n              blockNumber: result.blockNumber,\n              gasUsed: result.gasUsed,\n              logs: result.logs,\n              status: result.status,\n              transactionHash: result.transactionHash\n            };\n          }));\n          if (receipts.some(x => !x)) return {\n            status: 'PENDING',\n            receipts: []\n          };\n          return {\n            status: 'CONFIRMED',\n            receipts\n          };\n        }\n        if (method === 'wallet_showCallsStatus') return;\n        // other methods\n        if (method === 'personal_sign') {\n          if (features.signMessageError) {\n            if (typeof features.signMessageError === 'boolean') throw new UserRejectedRequestError(new Error('Failed to sign message.'));\n            throw features.signMessageError;\n          }\n          // Change `personal_sign` to `eth_sign` and swap params\n          method = 'eth_sign';\n          params = [params[1], params[0]];\n        }\n        const body = {\n          method,\n          params\n        };\n        const {\n          error,\n          result\n        } = await rpc.http(url, {\n          body\n        });\n        if (error) throw new RpcRequestError({\n          body,\n          error,\n          url\n        });\n        return result;\n      };\n      return custom({\n        request\n      })({\n        retryCount: 0\n      });\n    }\n  }));\n}","map":{"version":3,"names":["RpcRequestError","SwitchChainError","UserRejectedRequestError","custom","fromHex","getAddress","keccak256","numberToHex","stringToHex","rpc","ChainNotConfiguredError","ConnectorNotConnectedError","createConnector","mock","type","parameters","transactionCache","Map","features","connected","connectedChainId","config","id","name","setup","chains","connect","chainId","arguments","length","undefined","connectError","Error","provider","getProvider","accounts","request","method","currentChainId","getChainId","chain","switchChain","map","x","disconnect","getAccounts","hexChainId","isAuthorized","reconnect","_ref","find","params","onAccountsChanged","onDisconnect","emitter","emit","onChainChanged","Number","_error","url","rpcUrls","default","http","_ref2","signTypedDataError","switchChainError","toString","watchAssetError","paymasterService","supported","sessionKeys","hashes","calls","call","result","error","body","push","JSON","stringify","set","get","receipts","Promise","all","hash","blockHash","blockNumber","gasUsed","logs","status","transactionHash","some","signMessageError","retryCount"],"sources":["/Users/siddharthpranay/Desktop/projects/Chirping/frontend/node_modules/@wagmi/core/src/connectors/mock.ts"],"sourcesContent":["import {\n  type Address,\n  type EIP1193RequestFn,\n  type Hex,\n  RpcRequestError,\n  SwitchChainError,\n  type Transport,\n  UserRejectedRequestError,\n  type WalletCallReceipt,\n  type WalletRpcSchema,\n  custom,\n  fromHex,\n  getAddress,\n  keccak256,\n  numberToHex,\n  stringToHex,\n} from 'viem'\nimport { rpc } from 'viem/utils'\n\nimport {\n  ChainNotConfiguredError,\n  ConnectorNotConnectedError,\n} from '../errors/config.js'\nimport { createConnector } from './createConnector.js'\n\nexport type MockParameters = {\n  accounts: readonly [Address, ...Address[]]\n  features?:\n    | {\n        connectError?: boolean | Error | undefined\n        switchChainError?: boolean | Error | undefined\n        signMessageError?: boolean | Error | undefined\n        signTypedDataError?: boolean | Error | undefined\n        reconnect?: boolean | undefined\n        watchAssetError?: boolean | Error | undefined\n      }\n    | undefined\n}\n\nmock.type = 'mock' as const\nexport function mock(parameters: MockParameters) {\n  const transactionCache = new Map<Hex, Hex[]>()\n  const features = parameters.features ?? {}\n\n  type Provider = ReturnType<\n    Transport<'custom', unknown, EIP1193RequestFn<WalletRpcSchema>>\n  >\n  let connected = false\n  let connectedChainId: number\n\n  return createConnector<Provider>((config) => ({\n    id: 'mock',\n    name: 'Mock Connector',\n    type: mock.type,\n    async setup() {\n      connectedChainId = config.chains[0].id\n    },\n    async connect({ chainId } = {}) {\n      if (features.connectError) {\n        if (typeof features.connectError === 'boolean')\n          throw new UserRejectedRequestError(new Error('Failed to connect.'))\n        throw features.connectError\n      }\n\n      const provider = await this.getProvider()\n      const accounts = await provider.request({\n        method: 'eth_requestAccounts',\n      })\n\n      let currentChainId = await this.getChainId()\n      if (chainId && currentChainId !== chainId) {\n        const chain = await this.switchChain!({ chainId })\n        currentChainId = chain.id\n      }\n\n      connected = true\n\n      return {\n        accounts: accounts.map((x) => getAddress(x)),\n        chainId: currentChainId,\n      }\n    },\n    async disconnect() {\n      connected = false\n    },\n    async getAccounts() {\n      if (!connected) throw new ConnectorNotConnectedError()\n      const provider = await this.getProvider()\n      const accounts = await provider.request({ method: 'eth_accounts' })\n      return accounts.map((x) => getAddress(x))\n    },\n    async getChainId() {\n      const provider = await this.getProvider()\n      const hexChainId = await provider.request({ method: 'eth_chainId' })\n      return fromHex(hexChainId, 'number')\n    },\n    async isAuthorized() {\n      if (!features.reconnect) return false\n      if (!connected) return false\n      const accounts = await this.getAccounts()\n      return !!accounts.length\n    },\n    async switchChain({ chainId }) {\n      const provider = await this.getProvider()\n      const chain = config.chains.find((x) => x.id === chainId)\n      if (!chain) throw new SwitchChainError(new ChainNotConfiguredError())\n\n      await provider.request({\n        method: 'wallet_switchEthereumChain',\n        params: [{ chainId: numberToHex(chainId) }],\n      })\n      return chain\n    },\n    onAccountsChanged(accounts) {\n      if (accounts.length === 0) this.onDisconnect()\n      else\n        config.emitter.emit('change', {\n          accounts: accounts.map((x) => getAddress(x)),\n        })\n    },\n    onChainChanged(chain) {\n      const chainId = Number(chain)\n      config.emitter.emit('change', { chainId })\n    },\n    async onDisconnect(_error) {\n      config.emitter.emit('disconnect')\n      connected = false\n    },\n    async getProvider({ chainId } = {}) {\n      const chain =\n        config.chains.find((x) => x.id === chainId) ?? config.chains[0]\n      const url = chain.rpcUrls.default.http[0]!\n\n      const request: EIP1193RequestFn = async ({ method, params }) => {\n        // eth methods\n        if (method === 'eth_chainId') return numberToHex(connectedChainId)\n        if (method === 'eth_requestAccounts') return parameters.accounts\n        if (method === 'eth_signTypedData_v4')\n          if (features.signTypedDataError) {\n            if (typeof features.signTypedDataError === 'boolean')\n              throw new UserRejectedRequestError(\n                new Error('Failed to sign typed data.'),\n              )\n            throw features.signTypedDataError\n          }\n\n        // wallet methods\n        if (method === 'wallet_switchEthereumChain') {\n          if (features.switchChainError) {\n            if (typeof features.switchChainError === 'boolean')\n              throw new UserRejectedRequestError(\n                new Error('Failed to switch chain.'),\n              )\n            throw features.switchChainError\n          }\n          type Params = [{ chainId: Hex }]\n          connectedChainId = fromHex((params as Params)[0].chainId, 'number')\n          this.onChainChanged(connectedChainId.toString())\n          return\n        }\n\n        if (method === 'wallet_watchAsset') {\n          if (features.watchAssetError) {\n            if (typeof features.watchAssetError === 'boolean')\n              throw new UserRejectedRequestError(\n                new Error('Failed to switch chain.'),\n              )\n            throw features.watchAssetError\n          }\n          return connected\n        }\n\n        if (method === 'wallet_getCapabilities')\n          return {\n            '0x2105': {\n              paymasterService: {\n                supported:\n                  (params as [Hex])[0] ===\n                  '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266',\n              },\n              sessionKeys: {\n                supported: true,\n              },\n            },\n            '0x14A34': {\n              paymasterService: {\n                supported:\n                  (params as [Hex])[0] ===\n                  '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266',\n              },\n            },\n          }\n\n        if (method === 'wallet_sendCalls') {\n          const hashes = []\n          const calls = (params as any)[0].calls\n          for (const call of calls) {\n            const { result, error } = await rpc.http(url, {\n              body: {\n                method: 'eth_sendTransaction',\n                params: [call],\n              },\n            })\n            if (error)\n              throw new RpcRequestError({\n                body: { method, params },\n                error,\n                url,\n              })\n            hashes.push(result)\n          }\n          const id = keccak256(stringToHex(JSON.stringify(calls)))\n          transactionCache.set(id, hashes)\n          return id\n        }\n\n        if (method === 'wallet_getCallsStatus') {\n          const hashes = transactionCache.get((params as any)[0])\n          if (!hashes) return null\n          const receipts = await Promise.all(\n            hashes.map(async (hash) => {\n              const { result, error } = await rpc.http(url, {\n                body: {\n                  method: 'eth_getTransactionReceipt',\n                  params: [hash],\n                  id: 0,\n                },\n              })\n              if (error)\n                throw new RpcRequestError({\n                  body: { method, params },\n                  error,\n                  url,\n                })\n              if (!result) return null\n              return {\n                blockHash: result.blockHash,\n                blockNumber: result.blockNumber,\n                gasUsed: result.gasUsed,\n                logs: result.logs,\n                status: result.status,\n                transactionHash: result.transactionHash,\n              } satisfies WalletCallReceipt\n            }),\n          )\n          if (receipts.some((x) => !x))\n            return { status: 'PENDING', receipts: [] }\n          return { status: 'CONFIRMED', receipts }\n        }\n\n        if (method === 'wallet_showCallsStatus') return\n\n        // other methods\n        if (method === 'personal_sign') {\n          if (features.signMessageError) {\n            if (typeof features.signMessageError === 'boolean')\n              throw new UserRejectedRequestError(\n                new Error('Failed to sign message.'),\n              )\n            throw features.signMessageError\n          }\n          // Change `personal_sign` to `eth_sign` and swap params\n          method = 'eth_sign'\n          type Params = [data: Hex, address: Address]\n          params = [(params as Params)[1], (params as Params)[0]]\n        }\n\n        const body = { method, params }\n        const { error, result } = await rpc.http(url, { body })\n        if (error) throw new RpcRequestError({ body, error, url })\n\n        return result\n      }\n      return custom({ request })({ retryCount: 0 })\n    },\n  }))\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}