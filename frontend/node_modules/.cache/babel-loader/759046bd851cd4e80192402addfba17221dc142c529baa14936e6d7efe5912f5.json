{"ast":null,"code":"/** https://wagmi.sh/core/api/actions/disconnect */\nexport async function disconnect(config) {\n  let parameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let connector;\n  if (parameters.connector) connector = parameters.connector;else {\n    const {\n      connections,\n      current\n    } = config.state;\n    const connection = connections.get(current);\n    connector = connection?.connector;\n  }\n  const connections = config.state.connections;\n  if (connector) {\n    await connector.disconnect();\n    connector.emitter.off('change', config._internal.events.change);\n    connector.emitter.off('disconnect', config._internal.events.disconnect);\n    connector.emitter.on('connect', config._internal.events.connect);\n    connections.delete(connector.uid);\n  }\n  config.setState(x => {\n    // if no connections exist, move to disconnected state\n    if (connections.size === 0) return {\n      ...x,\n      connections: new Map(),\n      current: null,\n      status: 'disconnected'\n    };\n    // switch over to another connection\n    const nextConnection = connections.values().next().value;\n    return {\n      ...x,\n      connections: new Map(connections),\n      current: nextConnection.connector.uid\n    };\n  });\n  // Set recent connector if exists\n  {\n    const current = config.state.current;\n    if (!current) return;\n    const connector = config.state.connections.get(current)?.connector;\n    if (!connector) return;\n    await config.storage?.setItem('recentConnectorId', connector.id);\n  }\n}","map":{"version":3,"names":["disconnect","config","parameters","arguments","length","undefined","connector","connections","current","state","connection","get","emitter","off","_internal","events","change","on","connect","delete","uid","setState","x","size","Map","status","nextConnection","values","next","value","storage","setItem","id"],"sources":["/Users/siddharthpranay/Desktop/projects/Chirping/frontend/node_modules/@wagmi/core/src/actions/disconnect.ts"],"sourcesContent":["import type { Config, Connection, Connector } from '../createConfig.js'\nimport type { BaseErrorType, ErrorType } from '../errors/base.js'\nimport type {\n  ConnectorNotConnectedErrorType,\n  ConnectorNotFoundErrorType,\n} from '../errors/config.js'\nimport type { ConnectorParameter } from '../types/properties.js'\n\nexport type DisconnectParameters = ConnectorParameter\n\nexport type DisconnectReturnType = void\n\nexport type DisconnectErrorType =\n  | ConnectorNotFoundErrorType\n  | ConnectorNotConnectedErrorType\n  // base\n  | BaseErrorType\n  | ErrorType\n\n/** https://wagmi.sh/core/api/actions/disconnect */\nexport async function disconnect(\n  config: Config,\n  parameters: DisconnectParameters = {},\n): Promise<DisconnectReturnType> {\n  let connector: Connector | undefined\n  if (parameters.connector) connector = parameters.connector\n  else {\n    const { connections, current } = config.state\n    const connection = connections.get(current!)\n    connector = connection?.connector\n  }\n\n  const connections = config.state.connections\n\n  if (connector) {\n    await connector.disconnect()\n    connector.emitter.off('change', config._internal.events.change)\n    connector.emitter.off('disconnect', config._internal.events.disconnect)\n    connector.emitter.on('connect', config._internal.events.connect)\n\n    connections.delete(connector.uid)\n  }\n\n  config.setState((x) => {\n    // if no connections exist, move to disconnected state\n    if (connections.size === 0)\n      return {\n        ...x,\n        connections: new Map(),\n        current: null,\n        status: 'disconnected',\n      }\n\n    // switch over to another connection\n    const nextConnection = connections.values().next().value as Connection\n    return {\n      ...x,\n      connections: new Map(connections),\n      current: nextConnection.connector.uid,\n    }\n  })\n\n  // Set recent connector if exists\n  {\n    const current = config.state.current\n    if (!current) return\n    const connector = config.state.connections.get(current)?.connector\n    if (!connector) return\n    await config.storage?.setItem('recentConnectorId', connector.id)\n  }\n}\n"],"mappings":"AAmBA;AACA,OAAO,eAAeA,UAAUA,CAC9BC,MAAc,EACuB;EAAA,IAArCC,UAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAmC,EAAE;EAErC,IAAIG,SAAgC;EACpC,IAAIJ,UAAU,CAACI,SAAS,EAAEA,SAAS,GAAGJ,UAAU,CAACI,SAAS,MACrD;IACH,MAAM;MAAEC,WAAW;MAAEC;IAAO,CAAE,GAAGP,MAAM,CAACQ,KAAK;IAC7C,MAAMC,UAAU,GAAGH,WAAW,CAACI,GAAG,CAACH,OAAQ,CAAC;IAC5CF,SAAS,GAAGI,UAAU,EAAEJ,SAAS;EACnC;EAEA,MAAMC,WAAW,GAAGN,MAAM,CAACQ,KAAK,CAACF,WAAW;EAE5C,IAAID,SAAS,EAAE;IACb,MAAMA,SAAS,CAACN,UAAU,EAAE;IAC5BM,SAAS,CAACM,OAAO,CAACC,GAAG,CAAC,QAAQ,EAAEZ,MAAM,CAACa,SAAS,CAACC,MAAM,CAACC,MAAM,CAAC;IAC/DV,SAAS,CAACM,OAAO,CAACC,GAAG,CAAC,YAAY,EAAEZ,MAAM,CAACa,SAAS,CAACC,MAAM,CAACf,UAAU,CAAC;IACvEM,SAAS,CAACM,OAAO,CAACK,EAAE,CAAC,SAAS,EAAEhB,MAAM,CAACa,SAAS,CAACC,MAAM,CAACG,OAAO,CAAC;IAEhEX,WAAW,CAACY,MAAM,CAACb,SAAS,CAACc,GAAG,CAAC;EACnC;EAEAnB,MAAM,CAACoB,QAAQ,CAAEC,CAAC,IAAI;IACpB;IACA,IAAIf,WAAW,CAACgB,IAAI,KAAK,CAAC,EACxB,OAAO;MACL,GAAGD,CAAC;MACJf,WAAW,EAAE,IAAIiB,GAAG,EAAE;MACtBhB,OAAO,EAAE,IAAI;MACbiB,MAAM,EAAE;KACT;IAEH;IACA,MAAMC,cAAc,GAAGnB,WAAW,CAACoB,MAAM,EAAE,CAACC,IAAI,EAAE,CAACC,KAAmB;IACtE,OAAO;MACL,GAAGP,CAAC;MACJf,WAAW,EAAE,IAAIiB,GAAG,CAACjB,WAAW,CAAC;MACjCC,OAAO,EAAEkB,cAAc,CAACpB,SAAS,CAACc;KACnC;EACH,CAAC,CAAC;EAEF;EACA;IACE,MAAMZ,OAAO,GAAGP,MAAM,CAACQ,KAAK,CAACD,OAAO;IACpC,IAAI,CAACA,OAAO,EAAE;IACd,MAAMF,SAAS,GAAGL,MAAM,CAACQ,KAAK,CAACF,WAAW,CAACI,GAAG,CAACH,OAAO,CAAC,EAAEF,SAAS;IAClE,IAAI,CAACA,SAAS,EAAE;IAChB,MAAML,MAAM,CAAC6B,OAAO,EAAEC,OAAO,CAAC,mBAAmB,EAAEzB,SAAS,CAAC0B,EAAE,CAAC;EAClE;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}