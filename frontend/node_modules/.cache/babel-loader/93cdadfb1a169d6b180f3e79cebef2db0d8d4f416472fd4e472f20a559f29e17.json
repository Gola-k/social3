{"ast":null,"code":"import { createStore as createMipd } from 'mipd';\nimport { createClient } from 'viem';\nimport { persist, subscribeWithSelector } from 'zustand/middleware';\nimport { createStore } from 'zustand/vanilla';\nimport { injected } from './connectors/injected.js';\nimport { createEmitter } from './createEmitter.js';\nimport { createStorage, noopStorage } from './createStorage.js';\nimport { ChainNotConfiguredError } from './errors/config.js';\nimport { uid } from './utils/uid.js';\nimport { version } from './version.js';\nexport function createConfig(parameters) {\n  const {\n    multiInjectedProviderDiscovery = true,\n    storage = createStorage({\n      storage: typeof window !== 'undefined' && window.localStorage ? window.localStorage : noopStorage\n    }),\n    syncConnectedChain = true,\n    ssr = false,\n    ...rest\n  } = parameters;\n  /////////////////////////////////////////////////////////////////////////////////////////////////\n  // Set up connectors, clients, etc.\n  /////////////////////////////////////////////////////////////////////////////////////////////////\n  const mipd = typeof window !== 'undefined' && multiInjectedProviderDiscovery ? createMipd() : undefined;\n  const chains = createStore(() => rest.chains);\n  const connectors = createStore(() => [...(rest.connectors ?? []), ...(!ssr ? mipd?.getProviders().map(providerDetailToConnector) ?? [] : [])].map(setup));\n  function setup(connectorFn) {\n    // Set up emitter with uid and add to connector so they are \"linked\" together.\n    const emitter = createEmitter(uid());\n    const connector = {\n      ...connectorFn({\n        emitter,\n        chains: chains.getState(),\n        storage,\n        transports: rest.transports\n      }),\n      emitter,\n      uid: emitter.uid\n    };\n    // Start listening for `connect` events on connector setup\n    // This allows connectors to \"connect\" themselves without user interaction (e.g. MetaMask's \"Manually connect to current site\")\n    emitter.on('connect', connect);\n    connector.setup?.();\n    return connector;\n  }\n  function providerDetailToConnector(providerDetail) {\n    const {\n      info\n    } = providerDetail;\n    const provider = providerDetail.provider;\n    return injected({\n      target: {\n        ...info,\n        id: info.rdns,\n        provider\n      }\n    });\n  }\n  const clients = new Map();\n  function getClient() {\n    let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const chainId = config.chainId ?? store.getState().chainId;\n    const chain = chains.getState().find(x => x.id === chainId);\n    // chainId specified and not configured\n    if (config.chainId && !chain) throw new ChainNotConfiguredError();\n    {\n      const client = clients.get(store.getState().chainId);\n      if (client && !chain) return client;\n      if (!chain) throw new ChainNotConfiguredError();\n    }\n    // If a memoized client exists for a chain id, use that.\n    {\n      const client = clients.get(chainId);\n      if (client) return client;\n    }\n    let client;\n    if (rest.client) client = rest.client({\n      chain\n    });else {\n      const chainId = chain.id;\n      const chainIds = chains.getState().map(x => x.id);\n      // Grab all properties off `rest` and resolve for use in `createClient`\n      const properties = {};\n      const entries = Object.entries(rest);\n      for (const [key, value] of entries) {\n        if (key === 'chains' || key === 'client' || key === 'connectors' || key === 'transports') continue;\n        if (typeof value === 'object') {\n          // check if value is chainId-specific since some values can be objects\n          // e.g. { batch: { multicall: { batchSize: 1024 } } }\n          if (chainId in value) properties[key] = value[chainId];else {\n            // check if value is chainId-specific, but does not have value for current chainId\n            const hasChainSpecificValue = chainIds.some(x => x in value);\n            if (hasChainSpecificValue) continue;\n            properties[key] = value;\n          }\n        } else properties[key] = value;\n      }\n      client = createClient({\n        ...properties,\n        chain,\n        batch: properties.batch ?? {\n          multicall: true\n        },\n        transport: parameters => rest.transports[chainId]({\n          ...parameters,\n          connectors\n        })\n      });\n    }\n    clients.set(chainId, client);\n    return client;\n  }\n  /////////////////////////////////////////////////////////////////////////////////////////////////\n  // Create store\n  /////////////////////////////////////////////////////////////////////////////////////////////////\n  function getInitialState() {\n    return {\n      chainId: chains.getState()[0].id,\n      connections: new Map(),\n      current: null,\n      status: 'disconnected'\n    };\n  }\n  let currentVersion;\n  const prefix = '0.0.0-canary-';\n  if (version.startsWith(prefix)) currentVersion = Number.parseInt(version.replace(prefix, ''));\n  // use package major version to version store\n  else currentVersion = Number.parseInt(version.split('.')[0] ?? '0');\n  const store = createStore(subscribeWithSelector(\n  // only use persist middleware if storage exists\n  storage ? persist(getInitialState, {\n    migrate(persistedState, version) {\n      if (version === currentVersion) return persistedState;\n      const initialState = getInitialState();\n      const chainId = validatePersistedChainId(persistedState, initialState.chainId);\n      return {\n        ...initialState,\n        chainId\n      };\n    },\n    name: 'store',\n    partialize(state) {\n      // Only persist \"critical\" store properties to preserve storage size.\n      return {\n        connections: {\n          __type: 'Map',\n          value: Array.from(state.connections.entries()).map(_ref => {\n            let [key, connection] = _ref;\n            const {\n              id,\n              name,\n              type,\n              uid\n            } = connection.connector;\n            const connector = {\n              id,\n              name,\n              type,\n              uid\n            };\n            return [key, {\n              ...connection,\n              connector\n            }];\n          })\n        },\n        chainId: state.chainId,\n        current: state.current\n      };\n    },\n    merge(persistedState, currentState) {\n      // `status` should not be persisted as it messes with reconnection\n      if (typeof persistedState === 'object' && persistedState && 'status' in persistedState) delete persistedState.status;\n      // Make sure persisted `chainId` is valid\n      const chainId = validatePersistedChainId(persistedState, currentState.chainId);\n      return {\n        ...currentState,\n        ...persistedState,\n        chainId\n      };\n    },\n    skipHydration: ssr,\n    storage: storage,\n    version: currentVersion\n  }) : getInitialState));\n  function validatePersistedChainId(persistedState, defaultChainId) {\n    return persistedState && typeof persistedState === 'object' && 'chainId' in persistedState && typeof persistedState.chainId === 'number' && chains.getState().some(x => x.id === persistedState.chainId) ? persistedState.chainId : defaultChainId;\n  }\n  /////////////////////////////////////////////////////////////////////////////////////////////////\n  // Subscribe to changes\n  /////////////////////////////////////////////////////////////////////////////////////////////////\n  // Update default chain when connector chain changes\n  if (syncConnectedChain) store.subscribe(_ref2 => {\n    let {\n      connections,\n      current\n    } = _ref2;\n    return current ? connections.get(current)?.chainId : undefined;\n  }, chainId => {\n    // If chain is not configured, then don't switch over to it.\n    const isChainConfigured = chains.getState().some(x => x.id === chainId);\n    if (!isChainConfigured) return;\n    return store.setState(x => ({\n      ...x,\n      chainId: chainId ?? x.chainId\n    }));\n  });\n  // EIP-6963 subscribe for new wallet providers\n  mipd?.subscribe(providerDetails => {\n    const currentConnectorIds = new Map();\n    for (const connector of connectors.getState()) {\n      currentConnectorIds.set(connector.id, true);\n    }\n    const newConnectors = [];\n    for (const providerDetail of providerDetails) {\n      const connector = setup(providerDetailToConnector(providerDetail));\n      if (currentConnectorIds.has(connector.id)) continue;\n      newConnectors.push(connector);\n    }\n    if (storage && !store.persist.hasHydrated()) return;\n    connectors.setState(x => [...x, ...newConnectors], true);\n  });\n  /////////////////////////////////////////////////////////////////////////////////////////////////\n  // Emitter listeners\n  /////////////////////////////////////////////////////////////////////////////////////////////////\n  function change(data) {\n    store.setState(x => {\n      const connection = x.connections.get(data.uid);\n      if (!connection) return x;\n      return {\n        ...x,\n        connections: new Map(x.connections).set(data.uid, {\n          accounts: data.accounts ?? connection.accounts,\n          chainId: data.chainId ?? connection.chainId,\n          connector: connection.connector\n        })\n      };\n    });\n  }\n  function connect(data) {\n    // Disable handling if reconnecting/connecting\n    if (store.getState().status === 'connecting' || store.getState().status === 'reconnecting') return;\n    store.setState(x => {\n      const connector = connectors.getState().find(x => x.uid === data.uid);\n      if (!connector) return x;\n      if (connector.emitter.listenerCount('connect')) connector.emitter.off('connect', change);\n      if (!connector.emitter.listenerCount('change')) connector.emitter.on('change', change);\n      if (!connector.emitter.listenerCount('disconnect')) connector.emitter.on('disconnect', disconnect);\n      return {\n        ...x,\n        connections: new Map(x.connections).set(data.uid, {\n          accounts: data.accounts,\n          chainId: data.chainId,\n          connector: connector\n        }),\n        current: data.uid,\n        status: 'connected'\n      };\n    });\n  }\n  function disconnect(data) {\n    store.setState(x => {\n      const connection = x.connections.get(data.uid);\n      if (connection) {\n        const connector = connection.connector;\n        if (connector.emitter.listenerCount('change')) connection.connector.emitter.off('change', change);\n        if (connector.emitter.listenerCount('disconnect')) connection.connector.emitter.off('disconnect', disconnect);\n        if (!connector.emitter.listenerCount('connect')) connection.connector.emitter.on('connect', connect);\n      }\n      x.connections.delete(data.uid);\n      if (x.connections.size === 0) return {\n        ...x,\n        connections: new Map(),\n        current: null,\n        status: 'disconnected'\n      };\n      const nextConnection = x.connections.values().next().value;\n      return {\n        ...x,\n        connections: new Map(x.connections),\n        current: nextConnection.connector.uid\n      };\n    });\n  }\n  return {\n    get chains() {\n      return chains.getState();\n    },\n    get connectors() {\n      return connectors.getState();\n    },\n    storage,\n    getClient,\n    get state() {\n      return store.getState();\n    },\n    setState(value) {\n      let newState;\n      if (typeof value === 'function') newState = value(store.getState());else newState = value;\n      // Reset state if it got set to something not matching the base state\n      const initialState = getInitialState();\n      if (typeof newState !== 'object') newState = initialState;\n      const isCorrupt = Object.keys(initialState).some(x => !(x in newState));\n      if (isCorrupt) newState = initialState;\n      store.setState(newState, true);\n    },\n    subscribe(selector, listener, options) {\n      return store.subscribe(selector, listener, options ? {\n        ...options,\n        fireImmediately: options.emitImmediately\n        // Workaround cast since Zustand does not support `'exactOptionalPropertyTypes'`\n      } : undefined);\n    },\n    _internal: {\n      mipd,\n      store,\n      ssr: Boolean(ssr),\n      syncConnectedChain,\n      transports: rest.transports,\n      chains: {\n        setState(value) {\n          const nextChains = typeof value === 'function' ? value(chains.getState()) : value;\n          if (nextChains.length === 0) return;\n          return chains.setState(nextChains, true);\n        },\n        subscribe(listener) {\n          return chains.subscribe(listener);\n        }\n      },\n      connectors: {\n        providerDetailToConnector,\n        setup,\n        setState(value) {\n          return connectors.setState(typeof value === 'function' ? value(connectors.getState()) : value, true);\n        },\n        subscribe(listener) {\n          return connectors.subscribe(listener);\n        }\n      },\n      events: {\n        change,\n        connect,\n        disconnect\n      }\n    }\n  };\n}","map":{"version":3,"names":["createStore","createMipd","createClient","persist","subscribeWithSelector","injected","createEmitter","createStorage","noopStorage","ChainNotConfiguredError","uid","version","createConfig","parameters","multiInjectedProviderDiscovery","storage","window","localStorage","syncConnectedChain","ssr","rest","mipd","undefined","chains","connectors","getProviders","map","providerDetailToConnector","setup","connectorFn","emitter","connector","getState","transports","on","connect","providerDetail","info","provider","target","id","rdns","clients","Map","getClient","config","arguments","length","chainId","store","chain","find","x","client","get","chainIds","properties","entries","Object","key","value","hasChainSpecificValue","some","batch","multicall","transport","set","getInitialState","connections","current","status","currentVersion","prefix","startsWith","Number","parseInt","replace","split","migrate","persistedState","initialState","validatePersistedChainId","name","partialize","state","__type","Array","from","_ref","connection","type","merge","currentState","skipHydration","defaultChainId","subscribe","_ref2","isChainConfigured","setState","providerDetails","currentConnectorIds","newConnectors","has","push","hasHydrated","change","data","accounts","listenerCount","off","disconnect","delete","size","nextConnection","values","next","newState","isCorrupt","keys","selector","listener","options","fireImmediately","emitImmediately","_internal","Boolean","nextChains","events"],"sources":["/Users/siddharthpranay/Desktop/projects/Chirping/frontend/node_modules/@wagmi/core/src/createConfig.ts"],"sourcesContent":["import {\n  type EIP6963ProviderDetail,\n  type Store as MipdStore,\n  createStore as createMipd,\n} from 'mipd'\nimport {\n  type Address,\n  type Chain,\n  type Client,\n  type EIP1193RequestFn,\n  createClient,\n  type ClientConfig as viem_ClientConfig,\n  type Transport as viem_Transport,\n} from 'viem'\nimport { persist, subscribeWithSelector } from 'zustand/middleware'\nimport { type Mutate, type StoreApi, createStore } from 'zustand/vanilla'\n\nimport type {\n  ConnectorEventMap,\n  CreateConnectorFn,\n} from './connectors/createConnector.js'\nimport { injected } from './connectors/injected.js'\nimport { type Emitter, type EventData, createEmitter } from './createEmitter.js'\nimport { type Storage, createStorage, noopStorage } from './createStorage.js'\nimport { ChainNotConfiguredError } from './errors/config.js'\nimport type {\n  Compute,\n  ExactPartial,\n  LooseOmit,\n  OneOf,\n  RemoveUndefined,\n} from './types/utils.js'\nimport { uid } from './utils/uid.js'\nimport { version } from './version.js'\n\nexport type CreateConfigParameters<\n  chains extends readonly [Chain, ...Chain[]] = readonly [Chain, ...Chain[]],\n  transports extends Record<chains[number]['id'], Transport> = Record<\n    chains[number]['id'],\n    Transport\n  >,\n> = Compute<\n  {\n    chains: chains\n    connectors?: CreateConnectorFn[] | undefined\n    multiInjectedProviderDiscovery?: boolean | undefined\n    storage?: Storage | null | undefined\n    ssr?: boolean | undefined\n    syncConnectedChain?: boolean | undefined\n  } & OneOf<\n    | ({ transports: transports } & {\n        [key in keyof ClientConfig]?:\n          | ClientConfig[key]\n          | { [_ in chains[number]['id']]?: ClientConfig[key] | undefined }\n          | undefined\n      })\n    | {\n        client(parameters: { chain: chains[number] }): Client<\n          transports[chains[number]['id']],\n          chains[number]\n        >\n      }\n  >\n>\n\nexport function createConfig<\n  const chains extends readonly [Chain, ...Chain[]],\n  transports extends Record<chains[number]['id'], Transport>,\n>(\n  parameters: CreateConfigParameters<chains, transports>,\n): Config<chains, transports> {\n  const {\n    multiInjectedProviderDiscovery = true,\n    storage = createStorage({\n      storage:\n        typeof window !== 'undefined' && window.localStorage\n          ? window.localStorage\n          : noopStorage,\n    }),\n    syncConnectedChain = true,\n    ssr = false,\n    ...rest\n  } = parameters\n\n  /////////////////////////////////////////////////////////////////////////////////////////////////\n  // Set up connectors, clients, etc.\n  /////////////////////////////////////////////////////////////////////////////////////////////////\n\n  const mipd =\n    typeof window !== 'undefined' && multiInjectedProviderDiscovery\n      ? createMipd()\n      : undefined\n\n  const chains = createStore(() => rest.chains)\n  const connectors = createStore(() =>\n    [\n      ...(rest.connectors ?? []),\n      ...(!ssr\n        ? mipd?.getProviders().map(providerDetailToConnector) ?? []\n        : []),\n    ].map(setup),\n  )\n  function setup(connectorFn: CreateConnectorFn): Connector {\n    // Set up emitter with uid and add to connector so they are \"linked\" together.\n    const emitter = createEmitter<ConnectorEventMap>(uid())\n    const connector = {\n      ...connectorFn({\n        emitter,\n        chains: chains.getState(),\n        storage,\n        transports: rest.transports,\n      }),\n      emitter,\n      uid: emitter.uid,\n    }\n\n    // Start listening for `connect` events on connector setup\n    // This allows connectors to \"connect\" themselves without user interaction (e.g. MetaMask's \"Manually connect to current site\")\n    emitter.on('connect', connect)\n    connector.setup?.()\n\n    return connector\n  }\n  function providerDetailToConnector(providerDetail: EIP6963ProviderDetail) {\n    const { info } = providerDetail\n    const provider = providerDetail.provider as any\n    return injected({ target: { ...info, id: info.rdns, provider } })\n  }\n\n  const clients = new Map<number, Client<Transport, chains[number]>>()\n  function getClient<chainId extends chains[number]['id']>(\n    config: { chainId?: chainId | chains[number]['id'] | undefined } = {},\n  ): Client<Transport, Extract<chains[number], { id: chainId }>> {\n    const chainId = config.chainId ?? store.getState().chainId\n    const chain = chains.getState().find((x) => x.id === chainId)\n\n    // chainId specified and not configured\n    if (config.chainId && !chain) throw new ChainNotConfiguredError()\n\n    // If the target chain is not configured, use the client of the current chain.\n    type Return = Client<Transport, Extract<chains[number], { id: chainId }>>\n    {\n      const client = clients.get(store.getState().chainId)\n      if (client && !chain) return client as Return\n      if (!chain) throw new ChainNotConfiguredError()\n    }\n\n    // If a memoized client exists for a chain id, use that.\n    {\n      const client = clients.get(chainId)\n      if (client) return client as Return\n    }\n\n    let client: Client<Transport, chains[number]>\n    if (rest.client) client = rest.client({ chain })\n    else {\n      const chainId = chain.id as chains[number]['id']\n      const chainIds = chains.getState().map((x) => x.id)\n      // Grab all properties off `rest` and resolve for use in `createClient`\n      const properties: Partial<viem_ClientConfig> = {}\n      const entries = Object.entries(rest) as [keyof typeof rest, any][]\n\n      for (const [key, value] of entries) {\n        if (\n          key === 'chains' ||\n          key === 'client' ||\n          key === 'connectors' ||\n          key === 'transports'\n        )\n          continue\n\n        if (typeof value === 'object') {\n          // check if value is chainId-specific since some values can be objects\n          // e.g. { batch: { multicall: { batchSize: 1024 } } }\n          if (chainId in value) properties[key] = value[chainId]\n          else {\n            // check if value is chainId-specific, but does not have value for current chainId\n            const hasChainSpecificValue = chainIds.some((x) => x in value)\n            if (hasChainSpecificValue) continue\n            properties[key] = value\n          }\n        } else properties[key] = value\n      }\n\n      client = createClient({\n        ...properties,\n        chain,\n        batch: properties.batch ?? { multicall: true },\n        transport: (parameters) =>\n          rest.transports[chainId]({ ...parameters, connectors }),\n      })\n    }\n\n    clients.set(chainId, client)\n    return client as Return\n  }\n\n  /////////////////////////////////////////////////////////////////////////////////////////////////\n  // Create store\n  /////////////////////////////////////////////////////////////////////////////////////////////////\n\n  function getInitialState(): State {\n    return {\n      chainId: chains.getState()[0].id,\n      connections: new Map<string, Connection>(),\n      current: null,\n      status: 'disconnected',\n    }\n  }\n\n  let currentVersion: number\n  const prefix = '0.0.0-canary-'\n  if (version.startsWith(prefix))\n    currentVersion = Number.parseInt(version.replace(prefix, ''))\n  // use package major version to version store\n  else currentVersion = Number.parseInt(version.split('.')[0] ?? '0')\n\n  const store = createStore(\n    subscribeWithSelector(\n      // only use persist middleware if storage exists\n      storage\n        ? persist(getInitialState, {\n            migrate(persistedState, version) {\n              if (version === currentVersion) return persistedState as State\n\n              const initialState = getInitialState()\n              const chainId = validatePersistedChainId(\n                persistedState,\n                initialState.chainId,\n              )\n              return { ...initialState, chainId }\n            },\n            name: 'store',\n            partialize(state) {\n              // Only persist \"critical\" store properties to preserve storage size.\n              return {\n                connections: {\n                  __type: 'Map',\n                  value: Array.from(state.connections.entries()).map(\n                    ([key, connection]) => {\n                      const { id, name, type, uid } = connection.connector\n                      const connector = { id, name, type, uid }\n                      return [key, { ...connection, connector }]\n                    },\n                  ),\n                } as unknown as PartializedState['connections'],\n                chainId: state.chainId,\n                current: state.current,\n              } satisfies PartializedState\n            },\n            merge(persistedState, currentState) {\n              // `status` should not be persisted as it messes with reconnection\n              if (\n                typeof persistedState === 'object' &&\n                persistedState &&\n                'status' in persistedState\n              )\n                delete persistedState.status\n              // Make sure persisted `chainId` is valid\n              const chainId = validatePersistedChainId(\n                persistedState,\n                currentState.chainId,\n              )\n              return {\n                ...currentState,\n                ...(persistedState as object),\n                chainId,\n              }\n            },\n            skipHydration: ssr,\n            storage: storage as Storage<Record<string, unknown>>,\n            version: currentVersion,\n          })\n        : getInitialState,\n    ),\n  )\n\n  function validatePersistedChainId(\n    persistedState: unknown,\n    defaultChainId: number,\n  ) {\n    return persistedState &&\n      typeof persistedState === 'object' &&\n      'chainId' in persistedState &&\n      typeof persistedState.chainId === 'number' &&\n      chains.getState().some((x) => x.id === persistedState.chainId)\n      ? persistedState.chainId\n      : defaultChainId\n  }\n\n  /////////////////////////////////////////////////////////////////////////////////////////////////\n  // Subscribe to changes\n  /////////////////////////////////////////////////////////////////////////////////////////////////\n\n  // Update default chain when connector chain changes\n  if (syncConnectedChain)\n    store.subscribe(\n      ({ connections, current }) =>\n        current ? connections.get(current)?.chainId : undefined,\n      (chainId) => {\n        // If chain is not configured, then don't switch over to it.\n        const isChainConfigured = chains\n          .getState()\n          .some((x) => x.id === chainId)\n        if (!isChainConfigured) return\n\n        return store.setState((x) => ({\n          ...x,\n          chainId: chainId ?? x.chainId,\n        }))\n      },\n    )\n\n  // EIP-6963 subscribe for new wallet providers\n  mipd?.subscribe((providerDetails) => {\n    const currentConnectorIds = new Map()\n    for (const connector of connectors.getState()) {\n      currentConnectorIds.set(connector.id, true)\n    }\n\n    const newConnectors: Connector[] = []\n    for (const providerDetail of providerDetails) {\n      const connector = setup(providerDetailToConnector(providerDetail))\n      if (currentConnectorIds.has(connector.id)) continue\n      newConnectors.push(connector)\n    }\n\n    if (storage && !store.persist.hasHydrated()) return\n    connectors.setState((x) => [...x, ...newConnectors], true)\n  })\n\n  /////////////////////////////////////////////////////////////////////////////////////////////////\n  // Emitter listeners\n  /////////////////////////////////////////////////////////////////////////////////////////////////\n\n  function change(data: EventData<ConnectorEventMap, 'change'>) {\n    store.setState((x) => {\n      const connection = x.connections.get(data.uid)\n      if (!connection) return x\n      return {\n        ...x,\n        connections: new Map(x.connections).set(data.uid, {\n          accounts:\n            (data.accounts as readonly [Address, ...Address[]]) ??\n            connection.accounts,\n          chainId: data.chainId ?? connection.chainId,\n          connector: connection.connector,\n        }),\n      }\n    })\n  }\n  function connect(data: EventData<ConnectorEventMap, 'connect'>) {\n    // Disable handling if reconnecting/connecting\n    if (\n      store.getState().status === 'connecting' ||\n      store.getState().status === 'reconnecting'\n    )\n      return\n\n    store.setState((x) => {\n      const connector = connectors.getState().find((x) => x.uid === data.uid)\n      if (!connector) return x\n\n      if (connector.emitter.listenerCount('connect'))\n        connector.emitter.off('connect', change)\n      if (!connector.emitter.listenerCount('change'))\n        connector.emitter.on('change', change)\n      if (!connector.emitter.listenerCount('disconnect'))\n        connector.emitter.on('disconnect', disconnect)\n\n      return {\n        ...x,\n        connections: new Map(x.connections).set(data.uid, {\n          accounts: data.accounts as readonly [Address, ...Address[]],\n          chainId: data.chainId,\n          connector: connector,\n        }),\n        current: data.uid,\n        status: 'connected',\n      }\n    })\n  }\n  function disconnect(data: EventData<ConnectorEventMap, 'disconnect'>) {\n    store.setState((x) => {\n      const connection = x.connections.get(data.uid)\n      if (connection) {\n        const connector = connection.connector\n        if (connector.emitter.listenerCount('change'))\n          connection.connector.emitter.off('change', change)\n        if (connector.emitter.listenerCount('disconnect'))\n          connection.connector.emitter.off('disconnect', disconnect)\n        if (!connector.emitter.listenerCount('connect'))\n          connection.connector.emitter.on('connect', connect)\n      }\n\n      x.connections.delete(data.uid)\n\n      if (x.connections.size === 0)\n        return {\n          ...x,\n          connections: new Map(),\n          current: null,\n          status: 'disconnected',\n        }\n\n      const nextConnection = x.connections.values().next().value as Connection\n      return {\n        ...x,\n        connections: new Map(x.connections),\n        current: nextConnection.connector.uid,\n      }\n    })\n  }\n\n  return {\n    get chains() {\n      return chains.getState() as chains\n    },\n    get connectors() {\n      return connectors.getState()\n    },\n    storage,\n\n    getClient,\n    get state() {\n      return store.getState() as unknown as State<chains>\n    },\n    setState(value) {\n      let newState: State\n      if (typeof value === 'function') newState = value(store.getState() as any)\n      else newState = value\n\n      // Reset state if it got set to something not matching the base state\n      const initialState = getInitialState()\n      if (typeof newState !== 'object') newState = initialState\n      const isCorrupt = Object.keys(initialState).some((x) => !(x in newState))\n      if (isCorrupt) newState = initialState\n\n      store.setState(newState, true)\n    },\n    subscribe(selector, listener, options) {\n      return store.subscribe(\n        selector as unknown as (state: State) => any,\n        listener,\n        options\n          ? ({\n              ...options,\n              fireImmediately: options.emitImmediately,\n              // Workaround cast since Zustand does not support `'exactOptionalPropertyTypes'`\n            } as RemoveUndefined<typeof options>)\n          : undefined,\n      )\n    },\n\n    _internal: {\n      mipd,\n      store,\n      ssr: Boolean(ssr),\n      syncConnectedChain,\n      transports: rest.transports as transports,\n      chains: {\n        setState(value) {\n          const nextChains = (\n            typeof value === 'function' ? value(chains.getState()) : value\n          ) as chains\n          if (nextChains.length === 0) return\n          return chains.setState(nextChains, true)\n        },\n        subscribe(listener) {\n          return chains.subscribe(listener)\n        },\n      },\n      connectors: {\n        providerDetailToConnector,\n        setup,\n        setState(value) {\n          return connectors.setState(\n            typeof value === 'function' ? value(connectors.getState()) : value,\n            true,\n          )\n        },\n        subscribe(listener) {\n          return connectors.subscribe(listener)\n        },\n      },\n      events: { change, connect, disconnect },\n    },\n  }\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// Types\n/////////////////////////////////////////////////////////////////////////////////////////////////\n\nexport type Config<\n  chains extends readonly [Chain, ...Chain[]] = readonly [Chain, ...Chain[]],\n  transports extends Record<chains[number]['id'], Transport> = Record<\n    chains[number]['id'],\n    Transport\n  >,\n> = {\n  readonly chains: chains\n  readonly connectors: readonly Connector[]\n  readonly storage: Storage | null\n\n  readonly state: State<chains>\n  setState<tchains extends readonly [Chain, ...Chain[]] = chains>(\n    value: State<tchains> | ((state: State<tchains>) => State<tchains>),\n  ): void\n  subscribe<state>(\n    selector: (state: State<chains>) => state,\n    listener: (state: state, previousState: state) => void,\n    options?:\n      | {\n          emitImmediately?: boolean | undefined\n          equalityFn?: ((a: state, b: state) => boolean) | undefined\n        }\n      | undefined,\n  ): () => void\n\n  getClient<chainId extends chains[number]['id']>(parameters?: {\n    chainId?: chainId | chains[number]['id'] | undefined\n  }): Client<transports[chainId], Extract<chains[number], { id: chainId }>>\n\n  /**\n   * Not part of versioned API, proceed with caution.\n   * @internal\n   */\n  _internal: Internal<chains, transports>\n}\n\ntype Internal<\n  chains extends readonly [Chain, ...Chain[]] = readonly [Chain, ...Chain[]],\n  transports extends Record<chains[number]['id'], Transport> = Record<\n    chains[number]['id'],\n    Transport\n  >,\n> = {\n  readonly mipd: MipdStore | undefined\n  readonly store: Mutate<StoreApi<any>, [['zustand/persist', any]]>\n  readonly ssr: boolean\n  readonly syncConnectedChain: boolean\n  readonly transports: transports\n\n  chains: {\n    setState(\n      value:\n        | readonly [Chain, ...Chain[]]\n        | ((\n            state: readonly [Chain, ...Chain[]],\n          ) => readonly [Chain, ...Chain[]]),\n    ): void\n    subscribe(\n      listener: (\n        state: readonly [Chain, ...Chain[]],\n        prevState: readonly [Chain, ...Chain[]],\n      ) => void,\n    ): () => void\n  }\n  connectors: {\n    providerDetailToConnector(\n      providerDetail: EIP6963ProviderDetail,\n    ): CreateConnectorFn\n    setup(connectorFn: CreateConnectorFn): Connector\n    setState(value: Connector[] | ((state: Connector[]) => Connector[])): void\n    subscribe(\n      listener: (state: Connector[], prevState: Connector[]) => void,\n    ): () => void\n  }\n  events: {\n    change(data: EventData<ConnectorEventMap, 'change'>): void\n    connect(data: EventData<ConnectorEventMap, 'connect'>): void\n    disconnect(data: EventData<ConnectorEventMap, 'disconnect'>): void\n  }\n}\n\nexport type State<\n  chains extends readonly [Chain, ...Chain[]] = readonly [Chain, ...Chain[]],\n> = {\n  chainId: chains[number]['id']\n  connections: Map<string, Connection>\n  current: string | null\n  status: 'connected' | 'connecting' | 'disconnected' | 'reconnecting'\n}\n\nexport type PartializedState = Compute<\n  ExactPartial<Pick<State, 'chainId' | 'connections' | 'current' | 'status'>>\n>\n\nexport type Connection = {\n  accounts: readonly [Address, ...Address[]]\n  chainId: number\n  connector: Connector\n}\n\nexport type Connector = ReturnType<CreateConnectorFn> & {\n  emitter: Emitter<ConnectorEventMap>\n  uid: string\n}\n\nexport type Transport<\n  type extends string = string,\n  rpcAttributes = Record<string, any>,\n  eip1193RequestFn extends EIP1193RequestFn = EIP1193RequestFn,\n> = (\n  params: Parameters<\n    viem_Transport<type, rpcAttributes, eip1193RequestFn>\n  >[0] & {\n    connectors?: StoreApi<Connector[]> | undefined\n  },\n) => ReturnType<viem_Transport<type, rpcAttributes, eip1193RequestFn>>\n\ntype ClientConfig = LooseOmit<\n  viem_ClientConfig,\n  'account' | 'chain' | 'key' | 'name' | 'transport' | 'type'\n>\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}